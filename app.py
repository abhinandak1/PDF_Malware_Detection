from flask import Flask, render_template, request, redirect, url_for
import os
import subprocess
from collections import defaultdict
import csv
import numpy as np
from tensorflow.keras.models import load_model

app = Flask(__name__)

# Configure upload folder
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Function to check if file is allowed
# def allowed_file(filename):
#     return '.' in filename and filename.rsplit('.', 1)[1].lower() == 'pdf'

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    # Check if a file was uploaded
    if 'file' not in request.files:
        return redirect(request.url)
    file = request.files['file']
    # If user does not select file, browser also
    # submit an empty part without filename
    if file.filename == '':
        return redirect(request.url)

    filename = file.filename
    
    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))

    csv_file = "single_feature.csv"  # Replace with desired CSV file path
    extract_features_to_csv(os.path.join(app.config['UPLOAD_FOLDER'], filename), csv_file)

    # Load features from CSV
    data = np.array([load_features_from_csv(csv_file)])

    # Reshape the data for LSTM input (assuming 1 timestep and 25 features)
    features = data.reshape((data.shape[0], 1, data.shape[1]))

    # Predict using the model
    model = load_model('lstm.h5')
    predictions = model.predict(features)

    # Interpret the prediction
    if predictions < 0.5:
        result = "Non-malicious"
    else:
        result = "Malicious"
    return result


def extract_features(pdfid_output):
    features = defaultdict(int)
    lines = pdfid_output.split('\n')
    for line in lines:
        if line and ' ' in line:
            parts = line.split()
            try:
                feature = parts[0].lstrip('/')
                feature_count = int(parts[1])
                features[feature] = feature_count
            except ValueError:
                pass
    # Check if the "Colors" feature exists and set its binary value
    features['Colors'] = 1 if 'Colors' in features else 0
    return features

# Function to run pdfid on a PDF file and return its output
def run_pdfid(pdf_file):
    try:
        pdfid_output = subprocess.check_output(['pdfid', pdf_file], universal_newlines=True)
        return pdfid_output
    except subprocess.CalledProcessError:
        return None

# Function to write features to a CSV file without headings
def write_to_csv(features, csv_file):
    with open(csv_file, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        # Write counts row only, without headers
        writer.writerow(features.values())

# Main function to extract features from a PDF file and write to a CSV file
def extract_features_to_csv(pdf_file, csv_file):
    pdfid_output = run_pdfid(pdf_file)
    if pdfid_output:
        features = extract_features(pdfid_output)
        write_to_csv(features, csv_file)
        print("Features extracted successfully and saved to", csv_file)
    else:
        print("Error occurred while extracting features.")


def load_features_from_csv(csv_file):
    with open(csv_file, 'r') as file:
        reader = csv.reader(file)
        # Assuming the features are in the first row
        features = next(reader)
        # Convert features to integers
        features = [int(feature) for feature in features]
    return features

if __name__ == '__main__':
    app.run(debug=True)
