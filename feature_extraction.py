import os
import subprocess
import csv
from collections import defaultdict

# Function to extract features from pdfid output
def extract_features_pdfid(pdfid_output):
    features = defaultdict(int)
    lines = pdfid_output.split('\n')
    for line in lines:
        if line and ' ' in line:
            parts = line.split()
            try:
                feature = parts[0].lstrip('/')
                feature_count = int(parts[1])
                features[feature] = feature_count
            except ValueError:
                pass
    # Check if the "Colors" feature exists and set its binary value
    features['Colors'] = 1 if 'Colors' in features else 0
    return features

# Function to extract specified features from pdfinfo output
# def extract_features_pdfinfo(pdfinfo_output, specified_features):
#     features = {}
#     lines = pdfinfo_output.split('\n')
#     for line in lines:
#         if ':' in line:
#             key, value = line.split(':', 1)
#             key = key.strip()
#             if key in specified_features:
#                 features[key] = value.strip()
#     return features

def extract_features_pdfinfo(pdfinfo_output, specified_features):
    features = {}
    lines = pdfinfo_output.split('\n')
    for line in lines:
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            if key in specified_features:
                if key == 'File size':
                    value = value.split()[0]  # Exclude 'bytes' unit
                features[key] = value.strip()
    return features

# Function to run pdfid on a PDF file and return its output
def run_pdfid(pdf_file):
    try:
        pdfid_output = subprocess.check_output(['pdfid', pdf_file], universal_newlines=True)
        return pdfid_output
    except subprocess.CalledProcessError:
        return None

# Function to run pdfinfo on a PDF file and return its output
def run_pdfinfo(pdf_file):
    try:
        pdfinfo_output = subprocess.check_output(['pdfinfo', pdf_file], universal_newlines=True)
        return pdfinfo_output
    except subprocess.CalledProcessError:
        return None

# Function to write features to a CSV file
def write_to_csv(features, csv_file):
    features["Malicious"] = 1  # Adding the "Malicious" field with default value 0
    with open(csv_file, 'a', newline='') as csvfile:  # Append mode to add rows for each file
        writer = csv.DictWriter(csvfile, fieldnames=features.keys())
        if csvfile.tell() == 0:  # Check if the file is empty
            writer.writeheader()  # Write header only if the file is empty
        # Strip white spaces from column names and values
        stripped_features = {key.strip(): str(value).strip() for key, value in features.items()}
        writer.writerow(stripped_features)

# Main function to extract features from PDF files in a folder and write to a CSV file
def extract_features_from_folder(folder_path, csv_file):
    specified_features = [
        'Custom Metadata',
        'Metadata Stream',
        'Tagged',
        'UserProperties',
        'Suspects',
        'Form',
        'Encrypted',
        'Page rot',
        'File size',
        'Optimized',
        'PDF version'
    ]
    for filename in os.listdir(folder_path):
       # if filename.endswith('.pdf'):
            pdf_file = os.path.join(folder_path, filename)
            pdfid_output = run_pdfid(pdf_file)
            pdfinfo_output = run_pdfinfo(pdf_file)
            if pdfid_output and pdfinfo_output:
                pdfid_features = extract_features_pdfid(pdfid_output)
                pdfinfo_features = extract_features_pdfinfo(pdfinfo_output, specified_features)
                
                # Combine features from both tools
                combined_features = {**pdfid_features, **pdfinfo_features}
                
                write_to_csv(combined_features, csv_file)
                print("Features extracted successfully from", filename)
            else:
                print("Error occurred while extracting features from", filename)

    # Remove entries with empty "Malicious" field
    with open(csv_file, 'r', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        rows = [row for row in reader if row.get("Malicious")]
    
    # Write filtered rows back to the CSV file
    with open(csv_file, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=reader.fieldnames)
        writer.writeheader()
        writer.writerows(rows)

if __name__ == "__main__":
    folder_path = "../dump/mal/fl2"  # Replace with the path to your folder containing PDF files
    csv_file = "dataset_mal_new.csv"  # Replace with desired CSV file path
    extract_features_from_folder(folder_path, csv_file)